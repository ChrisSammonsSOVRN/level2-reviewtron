### **ğŸ“ Step 1: Initialize the Backend**
#### ğŸ¯ Goal: Set up a **Node.js Express backend** with **PostgreSQL**, **logging**, and **REST API endpoints** to start auditing websites.

---

## **ğŸ›  Step 1.1: Set Up the Project Directory**
ğŸ“Œ **Tasks:**
- [ ] Navigate to `backend/` and initialize a new Node.js project
- [ ] Create necessary subdirectories

ğŸ“Œ **Commands:**
```bash
cd backend
npm init -y
mkdir controllers routes database middlewares services utils tests
touch app.js .env .gitignore
```

ğŸ“Œ **.gitignore (Important for preventing sensitive files from being committed)**:
```gitignore
node_modules/
.env
logs/
```

---

## **ğŸ›  Step 1.2: Install Dependencies**
ğŸ“Œ **Core Backend Dependencies:**
```bash
npm install express dotenv cors helmet
```
- **express** â†’ Web framework
- **dotenv** â†’ Loads environment variables
- **cors** â†’ Manages Cross-Origin Resource Sharing
- **helmet** â†’ Secures HTTP headers

ğŸ“Œ **Database Dependencies:**
```bash
npm install pg pg-promise
```
- **pg** â†’ PostgreSQL driver
- **pg-promise** â†’ Easier SQL query handling

ğŸ“Œ **Development Dependencies:**
```bash
npm install --save-dev nodemon eslint
```
- **nodemon** â†’ Auto-restarts server on file changes
- **eslint** â†’ Ensures code quality

---

## **ğŸ›  Step 1.3: Create the Express Server**
ğŸ“Œ **File:** `backend/app.js`
```javascript
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');

const auditRoutes = require('./routes/auditRoutes');
const { logMessage } = require('./utils/logger');

const app = express();

app.use(express.json());
app.use(cors());
app.use(helmet());

app.use('/audit', auditRoutes); // Mount audit routes

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
    logMessage(`ğŸš€ Server running on port ${PORT}`);
});
```

---

## **ğŸ›  Step 1.4: Configure Environment Variables**
ğŸ“Œ **File:** `backend/.env`
```ini
PORT=5000
DB_USER=your_username
DB_PASS=your_password
DB_HOST=localhost
DB_NAME=audit_db
DB_PORT=5432
LOGGING_ENABLED=true
```

---

## **ğŸ›  Step 1.5: Set Up Database Connection**
ğŸ“Œ **File:** `backend/database/db.js`
```javascript
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
    user: process.env.DB_USER,
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    password: process.env.DB_PASS,
    port: process.env.DB_PORT || 5432
});

module.exports = pool;
```

ğŸ“Œ **Test Database Connection**
Create `backend/database/testConnection.js`:
```javascript
const pool = require('./db');

pool.query('SELECT NOW()', (err, res) => {
    if (err) console.error('Database connection error', err);
    else console.log('âœ… Database connected:', res.rows[0]);
    pool.end();
});
```

ğŸ“Œ **Run Test**
```bash
node database/testConnection.js
```
- âœ… **Success Output:** `"Database connected: { now: 'timestamp' }"`
- âŒ **Failure:** Check **`.env` credentials**

---

## **ğŸ›  Step 1.6: Implement Logging**
ğŸ“Œ **File:** `backend/utils/logger.js`
```javascript
const fs = require('fs');
const path = require('path');

const LOGGING_ENABLED = process.env.LOGGING_ENABLED === 'true';

const logFilePath = path.join(__dirname, '../logs/server.log');

function logMessage(message) {
    if (!LOGGING_ENABLED) return;

    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${message}\n`;
    console.log(logEntry);

    fs.appendFile(logFilePath, logEntry, (err) => {
        if (err) console.error('Error writing to log file', err);
    });
}

module.exports = { logMessage };
```

ğŸ“Œ **Modify `app.js` to Use Logger**
```javascript
const { logMessage } = require('./utils/logger');

app.listen(PORT, () => {
    logMessage(`ğŸš€ Server running on port ${PORT}`);
});
```

ğŸ“Œ **Run Server:**
```bash
node app.js
```
- âœ… **Success Output:** `ğŸš€ Server running on port 5000`

---

## **ğŸ›  Step 1.7: Create Audit API Route**
ğŸ“Œ **File:** `backend/routes/auditRoutes.js`
```javascript
const express = require('express');
const { analyzeURL } = require('../controllers/auditController');

const router = express.Router();

router.post('/url', async (req, res) => {
    const { url } = req.body;
    const result = await analyzeURL(url);
    res.json(result);
});

module.exports = router;
```

ğŸ“Œ **File:** `backend/controllers/auditController.js`
```javascript
const { logMessage } = require('../utils/logger');

async function analyzeURL(url) {
    logMessage(`ğŸ” Analyzing URL: ${url}`);

    const restrictedKeywords = ["porn", "gambling", "cannabis"];
    if (restrictedKeywords.some((word) => url.includes(word))) {
        logMessage(`âŒ FAIL - Adult Content Detected: ${url}`);
        return { status: "fail", reason: "Adult Content" };
    }

    logMessage(`âœ… PASS - URL Analysis Completed: ${url}`);
    return { status: "pass" };
}

module.exports = { analyzeURL };
```

ğŸ“Œ **Test API**
```bash
curl -X POST http://localhost:5000/audit/url -H "Content-Type: application/json" -d '{"url":"example.com"}'
```
- âœ… **Success Response:** `{"status": "pass"}`
- âŒ **Failure Response (Adult Content Detected):** `{"status": "fail", "reason": "Adult Content"}`

---

## **ğŸ›  Step 1.8: Automate with Nodemon**
ğŸ“Œ **File:** `backend/package.json` (Add `"start"` script)
```json
"scripts": {
    "start": "node app.js",
    "dev": "nodemon app.js"
}
```

ğŸ“Œ **Start Development Server**
```bash
npm run dev
```
- **Auto-restarts** when changes are detected ğŸ¯

---

# **ğŸ“ Step 1 Completion Checklist**
âœ… **Project Directory Set Up**  
âœ… **Express Installed & Configured**  
âœ… **PostgreSQL Connected & Tested**  
âœ… **Logging System Implemented**  
âœ… **Basic URL Filtering API Added**  
âœ… **Nodemon Configured for Auto-reloading**  



Based on your checklist, if you've completed all these steps and your tests (including the API and DB connection tests) are passing, then you're done with Step 1. The backend is now initialized, with the project structure, dependencies, Express server, environment configuration, database connection, logging system, and a basic audit API endpoint all in place.

Your next steps will be to build on this foundationâ€”moving into the advanced features or integration with your frontend/browser extension, as outlined in your roadmap.
---

